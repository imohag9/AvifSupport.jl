var documenterSearchIndex = {"docs":
[{"location":"reference/","page":"References","title":"References","text":"CurrentModule = AvifSupport","category":"page"},{"location":"reference/","page":"References","title":"References","text":"Modules = [AvifSupport]","category":"page"},{"location":"reference/#AvifSupport.avif_decode-Tuple{Vector{UInt8}}","page":"References","title":"AvifSupport.avif_decode","text":"avif_decode(filename::Union{AbstractString,IO}; kwargs...) -> Vector{Matrix{Colorant}}\navif_decode(data::Vector{UInt8}; kwargs...) -> Vector{Matrix{Colorant}}\n\nDecode the AVIF image as an array of colorant matrices. The source data can be either a filename, an IO , or an in-memory byte sequence.The output is an array of matrices of type Colorant.\n\nparameters\n\ntranspose::Bool: whether we need to permute the image's width and height dimension before encoding. The default value is false.\ninfo: Custom Decoding parameters\n\nLibAvif has a large number of decoder parameters that determine how the image is   decoded. Most applications don't need or want to know about all these parameters. For   more detailed information and explaination, please refer to the documents in [1].    Unsupported custom parameters might cause Julia segmentation fault.\nThe following are the default parameters used in this implementation for decoding :\ncodecChoice = libaom\nmaxThreads = Threads.nthreads()\nspeed = 4\n\nReferences\n\n[1] libavif avifdec.c \n\n\n\n\n\n","category":"method"},{"location":"reference/#AvifSupport.avif_encode-Union{Tuple{AbstractMatrix{TColor}}, Tuple{TColor}} where TColor<:ColorTypes.Colorant","page":"References","title":"AvifSupport.avif_encode","text":"avif_encode(image::AbstractMatrix{TColor}) -> Vector{UInt8}\navif_encode(image_arr::AbstractArray) -> Vector{UInt8}\n\nEncode 2D image imgor an array of 2D images image_arr as an AVIF byte sequence . The return value is a vector of bytes.\n\nParameters for avif_encode(image::AbstractMatrix{TColor})\n\ntranspose::Bool: whether we need to permute the image's width and height dimension\n\nbefore encoding. The default value is false.\n\nquality::Int: The quality value is between 0..100 . The default value is 10.\ntranspose::Bool: whether we need to permute the image's width and height dimension\nbefore encoding. The default value is false.\nmode::String: Determines the type of encoding of the input image .For 2D images ,  the encoding mode is one of two values : \"one_frame\" which is the default and \"grid\".\nParameters for avifencode(imagearr::AbstractArray)\ntranspose::Bool: whether we need to permute the image's width and height dimension\nbefore encoding. The default value is false.\nquality::Int: The quality value is between 0..100 . The\ndefault value is 10.\nmode::String: Determines the type of encoding of the input .For arrays of 2D images , \nthe encoding mode is one of three values : \"seq\" (for sequential) which is the default , \"grid\" or \"layered\" .\ngrid_cols::Int: - ONLY RELEVANT TO GRID ENCODING - Determines the number of columns of the resulting image .\nThe grid_cols value depends on the length of the input vector.  The default value is 1.\ngrid_rows::Int: - ONLY RELEVANT TO GRID ENCODING - Determines the number of rows of the resulting image .\nThe grid_rows value depends on the length of the input vector. The default value is 1.\ntimescale::Int: - ONLY RELEVANT TO LAYERED ENCODING - \ndefault value is 1.\n\ninfo: Custom Encoding parameters\nLibAvif has a large number of encoder parameters that determine how the image is encoded. Most applications don't need or want to know about all these parameters. For more detailed information and explaination, please refer to the document [1].  Unsupported custom parameters might cause Julia segmentation fault.The following are the default parameters used in this implementation for decoding :codecChoice = libaom\nmaxThreads = Threads.nthreads()\nspeed = 4\n\ndanger: For Grid Encoding\ngrid_cols * grid_rows = length(image_arr)\n\nReferences\n\n[1] libavif avifenc.c \n\n\n\n\n\n","category":"method"},{"location":"reference/#AvifSupport.is_valid_avif-Tuple{AbstractString}","page":"References","title":"AvifSupport.is_valid_avif","text":"is_valid_avif(file_path::AbstractString)\n\nReturns False if file_path is not a valid avif/avis file .\n\n\n\n\n\n","category":"method"},{"location":"reference/#AvifSupport.version_info","page":"References","title":"AvifSupport.version_info","text":"version_info(io=stdout)\n\nPrint information about the package the libavif in use.\n\n\n\n\n\n","category":"function"},{"location":"reference/#AvifSupport.write_avif-Tuple{AbstractString, AbstractMatrix{<:ColorTypes.Colorant}}","page":"References","title":"AvifSupport.write_avif","text":"write_avif(dest_file::AbstractString, image::AbstractMatrix{<:Colorant}; kwargs...) -> Integer\nwrite_avif(dest_file::AbstractString, image_arr::TVector; kwargs...) -> Integer\n\nUtility function that encodes a matrix of Colorant or an array of matrices of Colorant into a dest_file Avif image.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AvifSupport","category":"page"},{"location":"#AvifSupport","page":"Home","title":"AvifSupport","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AvifSupport.jl is a Julia wrapper of the C library libavif that provides IO support for the JPEG image format.","category":"page"},{"location":"#About-the-Avif-Format","page":"Home","title":"About the Avif Format","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AVIF (AV1 Image File Format) is an image format designed to offer superior image compression and quality compared to traditional formats. It delivers smaller file sizes without significant loss in quality, making it ideal for web applications, image storage, and streaming. Source : AOMedia","category":"page"},{"location":"#Add-the-package","page":"Home","title":"Add the package","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> # Press ]\npkg> activate\npkg> add githup-repo","category":"page"},{"location":"#General-parameters-for-encoding-and-decoding","page":"Home","title":"General parameters for encoding and decoding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"verbose : when set to true , Additional information are printed .Default value is false.","category":"page"},{"location":"","page":"Home","title":"Home","text":"transpose : Default false","category":"page"},{"location":"#Encoding","page":"Home","title":"Encoding","text":"","category":"section"},{"location":"#\"one-frame\"-Encoding","page":"Home","title":"\"one-frame\" Encoding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can simply encode a 2D image as an Avif file .It' the default encoding mode for still images. The quality paramater controls the quality of the resulting avif image. Its value is 10 by default. This parameter is available for all encoding modes and inputs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using AvifSupport\njulia> using TestImages\njulia> source_image = testimage(\"toucan.png\")\njulia> avif_result = avif_encode(source_image)\njulia> @show typeof(rgb_result)\njulia> avif_result2 = avif_encode(source_image,quality=100)","category":"page"},{"location":"#Grid-encoding","page":"Home","title":"Grid encoding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It's also possible to encode to Avif images in grid mode","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> avif_result = avif_encode(source_image,mode=\"grid\")","category":"page"},{"location":"#Encoding-Arrays-of-images","page":"Home","title":"Encoding Arrays of images","text":"","category":"section"},{"location":"#Grid-encoding-2","page":"Home","title":"Grid encoding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using Avif\njulia> using TestImages\njulia> src_img1 = testimage(\"fabio_color_256.png\")\njulia> src_img2 = testimage(\"fabio_gray_512.png\")\njulia> avif_result = avif_encode([src_img1,src_img2],mode=\"grid\",grid_cols=1,grid_rows=2)\njulia> @show typeof(rgb_result)","category":"page"},{"location":"#Sequential-encoding","page":"Home","title":"Sequential encoding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Timescale for image sequences. If all frames are 1 timescale in length, this is equivalent to frames per second. (Default: 30)","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using AvifSupport\njulia> using TestImages\njulia> src_img1 = testimage(\"fabio_color_256.png\")\njulia> src_img2 = testimage(\"fabio_gray_512.png\") \njulia> avif_result_seq = avif_encode([src_img1,src_img2],mode=\"seq\",timescale=60)\njulia> @show typeof(avif_result_seq)","category":"page"},{"location":"#Layered-encoding","page":"Home","title":"Layered encoding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Encode a layered AVIF. Each input is encoded as one layer and at most 4 layers can be encoded. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using AvifSupport\njulia> using TestImages\njulia> src_img1 = testimage(\"fabio_color_256\n.png\")\njulia> src_img2 = testimage(\"fabio_gray_512.\npng\")\njulia> avif_result_seq = avif_encode([src_im\ng1,src_img2],mode=\"layered\",timescale=60)\njulia> @show typeof(avif_result_seq)        ","category":"page"},{"location":"#Decoding-Avif-files","page":"Home","title":"Decoding Avif files","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using AvifSupport\njulia> using Downloads\njulia> avif_image = download(\"https://github.com/AOMediaCodec/libavif/blob/main/tests/data/io/kodim03_yuv420_8bpc.avif\")\njulia> rgb_result = avif_decode(avif_image)\njulia> @show typeof(rgb_result)","category":"page"},{"location":"","page":"Home","title":"Home","text":"File kodim03yuv4208bpc.avif License: released by the Eastman Kodak Company for unrestricted usage","category":"page"}]
}
